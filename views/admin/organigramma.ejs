<!-- Page header -->
<div class="page-header">
  <h1>
    <i class="fas fa-sitemap"></i>
    Organigramma Aziendale
  </h1>
  <p>Visualizza la struttura gerarchica del team ICONIC</p>
</div>

<!-- Stats organigramma -->
<div class="stats-grid">
  <div class="stat-card">
    <div class="stat-icon admin">
      <i class="fas fa-user-shield"></i>
    </div>
    <div class="stat-content">
      <div class="stat-number"><%= statistiche.admin %></div>
      <div class="stat-label">Amministratori</div>
    </div>
  </div>
  <div class="stat-card">
    <div class="stat-icon pre-admin">
      <i class="fas fa-user-cog"></i>
    </div>
    <div class="stat-content">
      <div class="stat-number"><%= statistiche.pre_admin %></div>
      <div class="stat-label">Pre-Admin</div>
    </div>
  </div>
  <div class="stat-card">
    <div class="stat-icon pr">
      <i class="fas fa-user-tie"></i>
    </div>
    <div class="stat-content">
      <div class="stat-number"><%= statistiche.pr %></div>
      <div class="stat-label">PR</div>
    </div>
  </div>
  <div class="stat-card">
    <div class="stat-icon total">
      <i class="fas fa-users"></i>
    </div>
    <div class="stat-content">
      <div class="stat-number"><%= statistiche.totale %></div>
      <div class="stat-label">Totale Staff</div>
    </div>
  </div>
</div>

<!-- Controlli organigramma -->
<div class="admin-card">
  <div class="card-header">
    <h2 class="card-title">
      <i class="fas fa-cogs"></i> 
      Controlli Visualizzazione
    </h2>
  </div>
  <div class="organigramma-controls">
    <button id="reset-view" class="control-btn">
      <i class="fas fa-home"></i>
      <span>Vista Completa</span>
    </button>
    <button id="zoom-in" class="control-btn">
      <i class="fas fa-search-plus"></i>
      <span>Zoom +</span>
    </button>
    <button id="zoom-out" class="control-btn">
      <i class="fas fa-search-minus"></i>
      <span>Zoom -</span>
    </button>
    <button id="toggle-roles" class="control-btn active">
      <i class="fas fa-tags"></i>
      <span>Ruoli</span>
    </button>
    <button id="toggle-grid" class="control-btn">
      <i class="fas fa-th"></i>
      <span>Griglia</span>
    </button>
  </div>
</div>

<!-- Canvas organigramma -->
<div class="admin-card">
  <div class="card-header">
    <h2 class="card-title">
      <i class="fas fa-sitemap"></i> 
      Struttura Organizzativa
    </h2>
  </div>
  <div class="organigramma-container">
    <!-- Loading indicator -->
    <div class="canvas-loading" id="canvas-loading">
      <div class="loading-spinner"></div>
      <div class="loading-text">Caricamento organigramma...</div>
    </div>
    
    <!-- Canvas -->
    <canvas id="organigramma-canvas"></canvas>
    
    <!-- Info panel -->
    <div class="organigramma-info">
      <div class="info-title">
        <i class="fas fa-info-circle"></i>
        Informazioni
      </div>
      <div class="info-item">
        <span class="info-label">Zoom:</span>
        <span class="info-value" id="zoom-level">100%</span>
      </div>
      <div class="info-item">
        <span class="info-label">Nodi visibili:</span>
        <span class="info-value" id="visible-nodes"><%= statistiche.totale %></span>
      </div>
      <div class="info-item">
        <span class="info-label">Livelli:</span>
        <span class="info-value" id="hierarchy-levels">3</span>
      </div>
    </div>
    
    <!-- Legend -->
    <div class="organigramma-legend">
      <div class="legend-title">
        <i class="fas fa-palette"></i>
        Legenda Ruoli
      </div>
      <div class="legend-item">
        <div class="legend-color admin"></div>
        <span>Amministratori</span>
      </div>
      <div class="legend-item">
        <div class="legend-color pre-admin"></div>
        <span>Pre-Admin</span>
      </div>
      <div class="legend-item">
        <div class="legend-color pr"></div>
        <span>PR</span>
      </div>
    </div>
  </div>
</div>

<!-- CSS per l'organigramma -->
<style>
.organigramma-controls {
  display: flex;
  gap: 1rem;
  flex-wrap: wrap;
  margin-bottom: 1rem;
}

.control-btn {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  padding: 0.875rem 1.25rem;
  border: 2px solid #e3eaf7;
  border-radius: 12px;
  background: #fff;
  color: #234e7d;
  cursor: pointer;
  transition: all 0.3s ease;
  font-weight: 600;
  min-width: 140px;
  justify-content: center;
  font-size: 0.95rem;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.control-btn:hover {
  border-color: #2b6cb0;
  background: #f7fafd;
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(43, 108, 176, 0.15);
}

.control-btn.active {
  background: linear-gradient(135deg, #2b6cb0 0%, #234e7d 100%);
  color: white;
  border-color: #2b6cb0;
  box-shadow: 0 4px 12px rgba(43, 108, 176, 0.3);
}

.control-btn i {
  font-size: 1.1rem;
}

.organigramma-container {
  width: 100%;
  /* Usa viewport height - spazio per header, stats, controlli e margini */
  height: calc(100vh - 420px);
  min-height: 500px;
  max-height: 900px;
  border: 3px solid #e3eaf7;
  border-radius: 16px;
  overflow: hidden;
  position: relative;
  background: linear-gradient(135deg, #f8fafc 0%, #ffffff 50%, #f1f5f9 100%);
  box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.05);
}

#organigramma-canvas {
  display: block;
  cursor: grab;
  width: 100%;
  height: 100%;
}

#organigramma-canvas:active {
  cursor: grabbing;
}

.stat-icon.total {
  background: linear-gradient(135deg, #6366f1, #8b5cf6);
}

/* Info panel */
.organigramma-info {
  position: absolute;
  top: 1rem;
  right: 1rem;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(43, 108, 176, 0.2);
  border-radius: 12px;
  padding: 1rem;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  z-index: 10;
  max-width: 250px;
}

.info-title {
  font-weight: 600;
  color: #234e7d;
  margin-bottom: 0.5rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.info-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.25rem 0;
  font-size: 0.9rem;
}

.info-label {
  color: #4a5568;
}

.info-value {
  font-weight: 600;
  color: #2b6cb0;
}

/* Legend */
.organigramma-legend {
  position: absolute;
  bottom: 1rem;
  left: 1rem;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(10px);
  border: 1px solid rgba(43, 108, 176, 0.2);
  border-radius: 12px;
  padding: 1rem;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  z-index: 10;
}

.legend-title {
  font-weight: 600;
  color: #234e7d;
  margin-bottom: 0.75rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  margin-bottom: 0.5rem;
  font-size: 0.9rem;
}

.legend-color {
  width: 20px;
  height: 12px;
  border-radius: 4px;
  border: 1px solid rgba(0, 0, 0, 0.1);
}

.legend-color.admin {
  background: #2b6cb0;
}

.legend-color.pre-admin {
  background: #ffd700;
}

.legend-color.pr {
  background: #38b000;
}

/* Responsive controls */
@media (max-width: 768px) {
  .organigramma-controls {
    justify-content: center;
    gap: 0.5rem;
  }
  
  .control-btn {
    min-width: 120px;
    font-size: 0.85rem;
    padding: 0.75rem 1rem;
  }
  
  .organigramma-container {
    /* Su mobile usa altezza fissa pi√π contenuta */
    height: calc(100vh - 500px);
    min-height: 400px;
    max-height: 600px;
  }

  .organigramma-info,
  .organigramma-legend {
    position: static;
    margin: 1rem 0;
    max-width: none;
  }
}

/* Loading animation */
.canvas-loading {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 1rem;
  color: #2b6cb0;
}

.loading-spinner {
  width: 40px;
  height: 40px;
  border: 4px solid #e3eaf7;
  border-top: 4px solid #2b6cb0;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.loading-text {
  font-weight: 600;
  font-size: 1.1rem;
}
</style>

<!-- JavaScript per l'organigramma -->
<script>
document.addEventListener('DOMContentLoaded', function() {
  console.log('üéØ Caricamento organigramma admin...');
  
  const canvas = document.getElementById('organigramma-canvas');
  const ctx = canvas ? canvas.getContext('2d') : null;
  const container = document.querySelector('.organigramma-container');
  const loadingEl = document.getElementById('canvas-loading');
  
  if (!canvas || !container) {
    console.error('‚ùå Elementi non trovati!');
    return;
  }
  
  // Dati dall'EJS
  const organigrammaData = <%- JSON.stringify(organigrammaData) %>;
  console.log('üìä Dati organigramma ricevuti:', organigrammaData);
  
  // Stato dell'organigramma
  let scale = 1;
  let offsetX = 0;
  let offsetY = 0;
  let isDragging = false;
  let showRoles = true;
  let showGrid = false;
  let hoveredNode = null;
  
  // Configurazione nodi migliorata per cerchi
  const nodeConfig = {
    radius: 50,
    padding: 20,
    fontSize: 12,
    titleFontSize: 14,
    shadowBlur: 12,
    spacing: {
      horizontal: 180,
      vertical: 120
    }
  };
  
  // Colori ruoli migliorati
  const roleColors = {
    admin: {
      bg: 'linear-gradient(135deg, #2b6cb0 0%, #1e4a6f 100%)',
      border: '#234e7d',
      text: '#ffffff',
      shadow: 'rgba(43, 108, 176, 0.3)'
    },
    pre_admin: {
      bg: 'linear-gradient(135deg, #ffd700 0%, #ffed4a 100%)',
      border: '#e6c200',
      text: '#1a1a1a',
      shadow: 'rgba(255, 215, 0, 0.3)'
    },
    pr: {
      bg: 'linear-gradient(135deg, #38b000 0%, #22c55e 100%)',
      border: '#267a00',
      text: '#ffffff',
      shadow: 'rgba(56, 176, 0, 0.3)'
    }
  };
  
  // Nasconde il loading
  function hideLoading() {
    if (loadingEl) {
      loadingEl.style.opacity = '0';
      setTimeout(() => loadingEl.style.display = 'none', 300);
    }
  }
  
  // Aggiorna le info
  function updateInfo() {
    const zoomEl = document.getElementById('zoom-level');
    const nodesEl = document.getElementById('visible-nodes');
    
    if (zoomEl) zoomEl.textContent = Math.round(scale * 100) + '%';
    if (nodesEl) nodesEl.textContent = organigrammaData.length;
  }
  
  // Imposta dimensioni canvas
  function resizeCanvas() {
    const rect = container.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    
    // Calcola dimensioni dinamiche basate sul numero di utenti
    const userCount = organigrammaData.length;
    const minWidth = 800;
    const minHeight = 500;
    
    // Aumenta le dimensioni se ci sono molti utenti
    const dynamicWidth = Math.max(minWidth, userCount * 80);
    const dynamicHeight = Math.max(minHeight, userCount * 60);
    
    console.log(`üìè [CANVAS RESIZE] Utenti: ${userCount}, Dimensioni: ${dynamicWidth}x${dynamicHeight}`);
    
    canvas.width = dynamicWidth * dpr;
    canvas.height = dynamicHeight * dpr;
    canvas.style.width = dynamicWidth + 'px';
    canvas.style.height = dynamicHeight + 'px';
    
    ctx.scale(dpr, dpr);
    drawOrganigramma();
  }
  
  // Costruisce l'albero gerarchico
  function buildTree(data) {
    console.log('üå≥ [BUILD TREE] Costruendo albero con', data.length, 'utenti');
    
    const nodes = new Map();
    const tree = [];
    
    // Prima passata: crea tutti i nodi
    data.forEach(person => {
      console.log(`üìã [NODE] Creando nodo: ${person.nickname} (ID: ${person.id}, Padre: ${person.padre_id})`);
      nodes.set(person.id, {
        ...person,
        children: []
      });
    });
    
    console.log('üóÇÔ∏è [NODES MAP] Nodi creati:', Array.from(nodes.keys()));
    
    // Seconda passata: costruisci le relazioni
    data.forEach(person => {
      const node = nodes.get(person.id);
      if (person.padre_id && nodes.has(person.padre_id)) {
        console.log(`üîó [RELATION] Collegando ${person.nickname} a ${nodes.get(person.padre_id).nickname}`);
        nodes.get(person.padre_id).children.push(node);
      } else {
        console.log(`üå≤ [ROOT] ${person.nickname} √® un nodo root (padre: ${person.padre_id})`);
        tree.push(node);
      }
    });
    
    console.log('üèÅ [RESULT] Albero costruito con', tree.length, 'nodi root');
    tree.forEach(root => {
      console.log(`üìä [ROOT] ${root.nickname} ha ${root.children.length} figli`);
    });
    
    return tree;
  }
  
  // Calcola layout con spaziatura migliorata per struttura circolare
  function calculateLayout(tree) {
    console.log('üìê [LAYOUT] Calcolando layout per', tree.length, 'nodi root');
    const positions = new Map();
    const occupiedPositions = new Set(); // Traccia posizioni occupate
    
    function isPositionOccupied(x, y) {
      const key = `${Math.round(x)}_${Math.round(y)}`;
      return occupiedPositions.has(key);
    }
    
    function markPositionOccupied(x, y) {
      const key = `${Math.round(x)}_${Math.round(y)}`;
      occupiedPositions.add(key);
    }
    
    function findAvailablePosition(preferredX, y, minSpacing = 120) {
      let x = preferredX;
      let attempts = 0;
      const maxAttempts = 50;
      
      // Prova prima la posizione preferita
      if (!isPositionOccupied(x, y)) {
        return x;
      }
      
      // Alterna sinistra e destra fino a trovare spazio
      for (let offset = minSpacing; attempts < maxAttempts; offset += minSpacing / 2) {
        attempts++;
        
        // Prova a destra
        x = preferredX + offset;
        if (!isPositionOccupied(x, y)) {
          console.log(`ÔøΩ [COLLISION AVOID] Spostato a destra: x:${x.toFixed(1)} (tentativo ${attempts})`);
          return x;
        }
        
        // Prova a sinistra
        x = preferredX - offset;
        if (!isPositionOccupied(x, y)) {
          console.log(`üîÑ [COLLISION AVOID] Spostato a sinistra: x:${x.toFixed(1)} (tentativo ${attempts})`);
          return x;
        }
      }
      
      // Fallback: forza una nuova posizione
      console.warn(`‚ö†Ô∏è [COLLISION] Nessuna posizione libera trovata, forzo offset`);
      return preferredX + (Math.random() - 0.5) * 300;
    }
    
    function traverse(node, depth, preferredX, parentX = null) {
      const y = depth * nodeConfig.spacing.vertical;
      
      // Trova una posizione libera
      const finalX = findAvailablePosition(preferredX, y);
      
      console.log(`üìç [POSITION] ${node.nickname} ‚Üí x:${finalX.toFixed(1)}, y:${y}, depth:${depth}`);
      
      // Marca la posizione come occupata
      markPositionOccupied(finalX, y);
      
      positions.set(node.id, { x: finalX, y, depth, parentX });
      
      if (node.children.length > 0) {
        console.log(`üë• [CHILDREN] ${node.nickname} ha ${node.children.length} figli`);
        
        const childCount = node.children.length;
        const minSpacing = Math.max(nodeConfig.spacing.horizontal, 140); // Spaziatura minima garantita
        
        // Per molti figli, aumenta automaticamente la spaziatura
        const dynamicSpacing = childCount > 10 ? minSpacing * 0.8 : 
                              childCount > 5 ? minSpacing * 0.9 : 
                              minSpacing;
        
        console.log(`üìè [SPACING] Usando spaziatura dinamica: ${dynamicSpacing.toFixed(1)} per ${childCount} figli`);
        
        // Distribuzione lineare ottimizzata per prevenire sovrapposizioni
        const totalWidth = (childCount - 1) * dynamicSpacing;
        const startX = finalX - totalWidth / 2;
        
        node.children.forEach((child, index) => {
          const childPreferredX = startX + index * dynamicSpacing;
          console.log(`üìê [LINEAR CHILD] ${child.nickname} ‚Üí index:${index}, preferredX:${childPreferredX.toFixed(1)}`);
          traverse(child, depth + 1, childPreferredX, finalX);
        });
      } else {
        console.log(`üçÉ [LEAF] ${node.nickname} √® una foglia`);
      }
    }
    
    // Posiziona i nodi root con spaziatura extra per molti root
    const rootCount = tree.length;
    const rootSpacing = Math.max(nodeConfig.spacing.horizontal * 2, 300);
    const startX = (rootCount - 1) * rootSpacing / 2;
    
    console.log(`üå≥ [ROOT SETUP] ${rootCount} root, spaziatura: ${rootSpacing}, startX: ${startX}`);
    
    tree.forEach((root, index) => {
      const rootX = -startX + index * rootSpacing;
      console.log(`üè† [ROOT] ${root.nickname} ‚Üí index:${index}, x:${rootX.toFixed(1)}`);
      traverse(root, 0, rootX);
    });
    
    console.log('üìä [LAYOUT RESULT] Posizioni calcolate:', positions.size);
    console.log('üö´ [COLLISIONS] Posizioni occupate:', occupiedPositions.size);
    
    // Debug finale delle posizioni
    for (let [id, pos] of positions) {
      console.log(`üìç [FINAL POSITION] ID:${id} ‚Üí x:${pos.x.toFixed(1)}, y:${pos.y}`);
    }
    
    return positions;
  }
  
  // Crea gradiente
  function createGradient(ctx, x, y, w, h, colorStr) {
    const gradient = ctx.createLinearGradient(x, y, x, y + h);
    
    if (colorStr.includes('gradient')) {
      // Estrae i colori dal CSS gradient
      const colors = colorStr.match(/#[a-fA-F0-9]{6}/g);
      if (colors && colors.length >= 2) {
        gradient.addColorStop(0, colors[0]);
        gradient.addColorStop(1, colors[1]);
      }
    } else {
      gradient.addColorStop(0, colorStr);
      gradient.addColorStop(1, colorStr);
    }
    
    return gradient;
  }
  
  // Disegna un nodo circolare con solo nickname
  function drawNode(person, x, y) {
    const colors = roleColors[person.ruolo] || roleColors.pr;
    const isHovered = hoveredNode === person.id;
    
    // Shadow con hover effect
    ctx.shadowColor = isHovered ? colors.shadow : 'rgba(0, 0, 0, 0.2)';
    ctx.shadowBlur = isHovered ? nodeConfig.shadowBlur * 1.5 : nodeConfig.shadowBlur;
    ctx.shadowOffsetX = isHovered ? 4 : 2;
    ctx.shadowOffsetY = isHovered ? 4 : 2;
    
    // Cerchio principale con gradiente
    const gradient = ctx.createRadialGradient(x, y, 0, x, y, nodeConfig.radius);
    
    if (colors.bg.includes('gradient')) {
      // Estrae i colori dal CSS gradient per il gradiente radiale
      const colorMatches = colors.bg.match(/#[a-fA-F0-9]{6}/g);
      if (colorMatches && colorMatches.length >= 2) {
        gradient.addColorStop(0, colorMatches[0]);
        gradient.addColorStop(0.7, colorMatches[1]);
        gradient.addColorStop(1, colorMatches[1]);
      }
    } else {
      gradient.addColorStop(0, colors.bg);
      gradient.addColorStop(1, colors.border);
    }
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(x, y, nodeConfig.radius, 0, 2 * Math.PI);
    ctx.fill();
    
    // Border del cerchio
    ctx.shadowColor = 'transparent';
    ctx.strokeStyle = colors.border;
    ctx.lineWidth = isHovered ? 4 : 3;
    ctx.beginPath();
    ctx.arc(x, y, nodeConfig.radius, 0, 2 * Math.PI);
    ctx.stroke();
    
    // Cerchio interno per effetto hover
    if (isHovered) {
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x, y, nodeConfig.radius - 5, 0, 2 * Math.PI);
      ctx.stroke();
    }
    
    // Testo - solo nickname al centro
    ctx.fillStyle = colors.text;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
    ctx.shadowBlur = 3;
    ctx.shadowOffsetX = 1;
    ctx.shadowOffsetY = 1;
    
    // Nickname al centro del cerchio
    ctx.font = `bold ${nodeConfig.titleFontSize}px "Segoe UI", system-ui, sans-serif`;
    
    // Tronca il nickname se troppo lungo per il cerchio
    let displayNickname = person.nickname;
    const maxWidth = (nodeConfig.radius - 10) * 2;
    
    if (ctx.measureText(displayNickname).width > maxWidth) {
      while (ctx.measureText(displayNickname + '...').width > maxWidth && displayNickname.length > 3) {
        displayNickname = displayNickname.slice(0, -1);
      }
      displayNickname += '...';
    }
    
    ctx.fillText(displayNickname, x, y - 5);
    
    // Ruolo sotto il nickname (pi√π piccolo)
    if (showRoles) {
      ctx.font = `bold ${nodeConfig.fontSize}px "Segoe UI", system-ui, sans-serif`;
      const roleText = person.ruolo === 'pre_admin' ? 'PRE-ADMIN' : person.ruolo.toUpperCase();
      ctx.fillText(roleText, x, y + 12);
    }
    
    ctx.shadowColor = 'transparent';
  }
  
  // Rettangoli arrotondati migliorati
  function roundRect(ctx, x, y, width, height, radius) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.arcTo(x + width, y, x + width, y + height, radius);
    ctx.arcTo(x + width, y + height, x, y + height, radius);
    ctx.arcTo(x, y + height, x, y, radius);
    ctx.arcTo(x, y, x + width, y, radius);
    ctx.closePath();
  }
  
  // Disegna connessioni con stile migliorato per cerchi
  function drawConnections(tree, positions) {
    ctx.strokeStyle = '#64748b';
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    // Ombra per le linee
    ctx.shadowColor = 'rgba(0, 0, 0, 0.15)';
    ctx.shadowBlur = 4;
    ctx.shadowOffsetX = 2;
    ctx.shadowOffsetY = 2;
    
    function drawNodeConnections(node) {
      const nodePos = positions.get(node.id);
      if (!nodePos) return;
      
      node.children.forEach(child => {
        const childPos = positions.get(child.id);
        if (!childPos) return;
        
        // Calcola i punti di connessione sui bordi dei cerchi
        const dx = childPos.x - nodePos.x;
        const dy = childPos.y - nodePos.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Punti di partenza e arrivo sui bordi dei cerchi
        const fromX = nodePos.x + (dx / distance) * nodeConfig.radius;
        const fromY = nodePos.y + (dy / distance) * nodeConfig.radius;
        const toX = childPos.x - (dx / distance) * nodeConfig.radius;
        const toY = childPos.y - (dy / distance) * nodeConfig.radius;
        
        // Linea curva pi√π organica
        ctx.beginPath();
        ctx.moveTo(fromX, fromY);
        
        // Calcola i punti di controllo per una curva pi√π naturale
        const midY = fromY + (toY - fromY) * 0.5;
        const controlOffset = Math.abs(dx) * 0.2;
        
        const cp1X = fromX;
        const cp1Y = fromY + controlOffset;
        const cp2X = toX;
        const cp2Y = toY - controlOffset;
        
        ctx.bezierCurveTo(cp1X, cp1Y, cp2X, cp2Y, toX, toY);
        ctx.stroke();
        
        // Freccia pi√π piccola e elegante
        const arrowSize = 6;
        const angle = Math.atan2(dy, dx);
        
        ctx.fillStyle = '#64748b';
        ctx.beginPath();
        ctx.moveTo(toX, toY);
        ctx.lineTo(toX - arrowSize * Math.cos(angle - Math.PI / 6), toY - arrowSize * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(toX - arrowSize * Math.cos(angle + Math.PI / 6), toY - arrowSize * Math.sin(angle + Math.PI / 6));
        ctx.closePath();
        ctx.fill();
        
        drawNodeConnections(child);
      });
    }
    
    tree.forEach(root => drawNodeConnections(root));
    ctx.shadowColor = 'transparent';
  }
  
  // Controlla se il mouse √® sopra un cerchio
  function getNodeAtPosition(mouseX, mouseY, positions) {
    const rect = canvas.getBoundingClientRect();
    const x = (mouseX - rect.left - offsetX) / scale;
    const y = (mouseY - rect.top - offsetY) / scale;
    
    const centerX = canvas.width / (2 * (window.devicePixelRatio || 1)) / scale;
    const centerY = 50;
    const adjustedX = x - centerX;
    const adjustedY = y - centerY;
    
    for (let [id, pos] of positions) {
      // Calcola la distanza dal centro del cerchio
      const distance = Math.sqrt(Math.pow(adjustedX - pos.x, 2) + Math.pow(adjustedY - pos.y, 2));
      
      if (distance <= nodeConfig.radius) {
        return id;
      }
    }
    return null;
  }
  
  // Disegna griglia di aiuto
  function drawGrid() {
    if (!showGrid) return;
    
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.lineWidth = 1;
    ctx.setLineDash([5, 5]);
    
    const rect = container.getBoundingClientRect();
    const gridSize = 50;
    
    // Linee verticali
    for (let x = -1000; x <= 1000; x += gridSize) {
      ctx.beginPath();
      ctx.moveTo(x, -1000);
      ctx.lineTo(x, 1000);
      ctx.stroke();
    }
    
    // Linee orizzontali
    for (let y = -1000; y <= 1000; y += gridSize) {
      ctx.beginPath();
      ctx.moveTo(-1000, y);
      ctx.lineTo(1000, y);
      ctx.stroke();
    }
    
    ctx.setLineDash([]);
  }
  
  // Disegna l'organigramma completo
  function drawOrganigramma() {
    const rect = container.getBoundingClientRect();
    ctx.clearRect(0, 0, rect.width, rect.height);
    
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(scale, scale);
    
    const centerX = rect.width / 2 / scale;
    const centerY = 50;
    ctx.translate(centerX, centerY);
    
    console.log('üé® [DRAW] Inizio disegno organigramma');
    console.log('üìê [CANVAS] Dimensioni:', rect.width, 'x', rect.height);
    console.log('üéØ [TRANSFORM] Center:', centerX.toFixed(1), centerY, 'Scale:', scale.toFixed(2), 'Offset:', offsetX.toFixed(1), offsetY.toFixed(1));
    
    // Disegna griglia se abilitata
    drawGrid();
    
    const tree = buildTree(organigrammaData);
    const positions = calculateLayout(tree);
    
    // Auto-zoom per adattarsi a molti nodi
    const userCount = organigrammaData.length;
    if (userCount > 20 && scale === 1) {
      const autoZoom = Math.max(0.3, 1 - (userCount - 20) * 0.02);
      scale = autoZoom;
      console.log(`üîç [AUTO ZOOM] ${userCount} utenti, zoom automatico: ${(autoZoom * 100).toFixed(1)}%`);
    }
    
    drawConnections(tree, positions);
    
    let drawnNodes = 0;
    let overlappingNodes = [];
    const drawnPositions = new Set();
    
    organigrammaData.forEach(person => {
      const pos = positions.get(person.id);
      if (pos) {
        const posKey = `${Math.round(pos.x)}_${Math.round(pos.y)}`;
        
        if (drawnPositions.has(posKey)) {
          overlappingNodes.push(person.nickname);
          console.warn(`‚ö†Ô∏è [OVERLAP WARNING] ${person.nickname} potrebbe sovrapporsi a posizione ${posKey}`);
        } else {
          drawnPositions.add(posKey);
        }
        
        console.log(`üñåÔ∏è [DRAWING] ${person.nickname} a posizione x:${pos.x.toFixed(1)}, y:${pos.y}`);
        drawNode(person, pos.x, pos.y);
        drawnNodes++;
      } else {
        console.warn(`‚ùå [MISSING POSITION] ${person.nickname} non ha posizione!`);
      }
    });
    
    console.log(`‚úÖ [DRAW COMPLETE] Disegnati ${drawnNodes} nodi su ${organigrammaData.length} totali`);
    if (overlappingNodes.length > 0) {
      console.warn(`‚ö†Ô∏è [OVERLAPS DETECTED] Potenziali sovrapposizioni: ${overlappingNodes.join(', ')}`);
    } else {
      console.log(`‚ú® [NO OVERLAPS] Nessuna sovrapposizione rilevata!`);
    }
    
    ctx.restore();
    updateInfo();
  }
  
  // Event listeners per controlli
  document.getElementById('reset-view').addEventListener('click', () => {
    scale = 1;
    offsetX = 0;
    offsetY = 0;
    drawOrganigramma();
  });
  
  document.getElementById('zoom-in').addEventListener('click', () => {
    scale = Math.min(scale * 1.2, 3);
    drawOrganigramma();
  });
  
  document.getElementById('zoom-out').addEventListener('click', () => {
    scale = Math.max(scale / 1.2, 0.3);
    drawOrganigramma();
  });
  
  document.getElementById('toggle-roles').addEventListener('click', (e) => {
    showRoles = !showRoles;
    e.target.classList.toggle('active');
    drawOrganigramma();
  });
  
  document.getElementById('toggle-grid').addEventListener('click', (e) => {
    showGrid = !showGrid;
    e.target.classList.toggle('active');
    drawOrganigramma();
  });
  
  // Mouse events migliorati
  let lastMouseX, lastMouseY;
  
  canvas.addEventListener('mousedown', (e) => {
    isDragging = true;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
    canvas.style.cursor = 'grabbing';
  });
  
  canvas.addEventListener('mousemove', (e) => {
    if (isDragging) {
      const deltaX = e.clientX - lastMouseX;
      const deltaY = e.clientY - lastMouseY;
      offsetX += deltaX;
      offsetY += deltaY;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      drawOrganigramma();
    } else {
      // Hover effect
      const tree = buildTree(organigrammaData);
      const positions = calculateLayout(tree);
      const nodeId = getNodeAtPosition(e.clientX, e.clientY, positions);
      
      if (nodeId !== hoveredNode) {
        hoveredNode = nodeId;
        canvas.style.cursor = nodeId ? 'pointer' : 'grab';
        drawOrganigramma();
      }
    }
  });
  
  canvas.addEventListener('mouseup', () => {
    isDragging = false;
    canvas.style.cursor = hoveredNode ? 'pointer' : 'grab';
  });
  
  canvas.addEventListener('mouseleave', () => {
    isDragging = false;
    hoveredNode = null;
    canvas.style.cursor = 'grab';
    drawOrganigramma();
  });
  
  // Zoom con scroll migliorato
  canvas.addEventListener('wheel', (e) => {
    e.preventDefault();
    const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
    const newScale = Math.min(Math.max(scale * zoomFactor, 0.3), 3);
    
    // Zoom verso il punto del mouse
    const rect = canvas.getBoundingClientRect();
    const mouseX = e.clientX - rect.left;
    const mouseY = e.clientY - rect.top;
    
    const scaleChange = newScale / scale;
    offsetX = mouseX - (mouseX - offsetX) * scaleChange;
    offsetY = mouseY - (mouseY - offsetY) * scaleChange;
    
    scale = newScale;
    drawOrganigramma();
  });
  
  // Resize handler
  window.addEventListener('resize', resizeCanvas);
  
  // Inizializza con animazione
  setTimeout(() => {
    resizeCanvas();
    hideLoading();
    console.log('‚úÖ Organigramma caricato con successo!');
  }, 500);
});
</script>
