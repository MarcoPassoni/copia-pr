/**
 * VULNERABILITY TEST - ICONIC Dashboard
 * Test completo di sicurezza per identificare vulnerabilit√†
 * Data: November 2025
 */

const fs = require('fs');
const path = require('path');
const crypto = require('crypto');

console.log('üîç ICONIC VULNERABILITY TEST - Avvio analisi sicurezza...\n');

// ========================================
// CONFIGURAZIONE TEST
// ========================================
const VULNERABILITY_CATEGORIES = {
    CRITICAL: 'üî¥ CRITICO',
    HIGH: 'üü† ALTO',
    MEDIUM: 'üü° MEDIO', 
    LOW: 'üü¢ BASSO',
    INFO: '‚ÑπÔ∏è  INFO'
};

let vulnerabilities = [];
let scannedFiles = 0;
let totalLines = 0;

// ========================================
// FUNZIONI DI UTILIT√Ä
// ========================================
function addVulnerability(severity, category, description, file, line = null) {
    vulnerabilities.push({
        severity,
        category,
        description,
        file: file.replace(process.cwd(), ''),
        line,
        timestamp: new Date().toISOString()
    });
}

function scanFile(filePath) {
    if (!fs.existsSync(filePath)) return null;
    
    const content = fs.readFileSync(filePath, 'utf8');
    const lines = content.split('\n');
    totalLines += lines.length;
    scannedFiles++;
    
    return { content, lines };
}

function scanDirectory(dir, extensions = ['.js', '.ejs', '.json']) {
    const files = [];
    
    function scanRecursive(currentDir) {
        try {
            const items = fs.readdirSync(currentDir);
            
            for (const item of items) {
                const fullPath = path.join(currentDir, item);
                const stat = fs.statSync(fullPath);
                
                if (stat.isDirectory() && !item.startsWith('.') && item !== 'node_modules') {
                    scanRecursive(fullPath);
                } else if (stat.isFile() && extensions.some(ext => item.endsWith(ext))) {
                    files.push(fullPath);
                }
            }
        } catch (err) {
            console.log(`‚ùå Errore lettura directory ${currentDir}: ${err.message}`);
        }
    }
    
    scanRecursive(dir);
    return files;
}

// ========================================
// TEST SPECIFICI
// ========================================

// 1. SQL INJECTION
function testSQLInjection() {
    console.log('üîç Test SQL Injection...');
    
    const sqlFiles = scanDirectory('.', ['.js']);
    const dangerousPatterns = [
        /db\.run\s*\(\s*[`"'].*\$\{.*\}.*[`"']/g,
        /db\.get\s*\(\s*[`"'].*\$\{.*\}.*[`"']/g,
        /db\.all\s*\(\s*[`"'].*\$\{.*\}.*[`"']/g,
        /query\s*\+=\s*.*\+/g,
        /SELECT.*\+.*FROM/gi,
        /WHERE.*\+.*=/gi
    ];
    
    sqlFiles.forEach(file => {
        const scan = scanFile(file);
        if (!scan) return;
        
        scan.lines.forEach((line, index) => {
            dangerousPatterns.forEach(pattern => {
                if (pattern.test(line)) {
                    addVulnerability(
                        VULNERABILITY_CATEGORIES.CRITICAL,
                        'SQL Injection',
                        `Possibile SQL injection: ${line.trim()}`,
                        file,
                        index + 1
                    );
                }
            });
            
            // Check for direct string concatenation in queries
            if (line.includes('db.') && (line.includes('+') || line.includes('${')) && 
                (line.includes('SELECT') || line.includes('INSERT') || line.includes('UPDATE') || line.includes('DELETE'))) {
                addVulnerability(
                    VULNERABILITY_CATEGORIES.HIGH,
                    'SQL Injection',
                    `Query dinamica senza parametri: ${line.trim()}`,
                    file,
                    index + 1
                );
            }
        });
    });
}

// 2. XSS (Cross-Site Scripting)
function testXSS() {
    console.log('üîç Test XSS (Cross-Site Scripting)...');
    
    const webFiles = scanDirectory('.', ['.ejs', '.js']);
    
    webFiles.forEach(file => {
        const scan = scanFile(file);
        if (!scan) return;
        
        scan.lines.forEach((line, index) => {
            // Unescaped output in EJS
            if (line.includes('<%=') && !line.includes('<%%-')) {
                addVulnerability(
                    VULNERABILITY_CATEGORIES.MEDIUM,
                    'XSS',
                    `Output non escapato: ${line.trim()}`,
                    file,
                    index + 1
                );
            }
            
            // innerHTML usage
            if (line.includes('innerHTML') && line.includes('=')) {
                addVulnerability(
                    VULNERABILITY_CATEGORIES.HIGH,
                    'XSS',
                    `innerHTML dinamico: ${line.trim()}`,
                    file,
                    index + 1
                );
            }
            
            // eval() usage
            if (line.includes('eval(')) {
                addVulnerability(
                    VULNERABILITY_CATEGORIES.CRITICAL,
                    'Code Injection',
                    `Uso di eval(): ${line.trim()}`,
                    file,
                    index + 1
                );
            }
        });
    });
}

// 3. Authentication & Authorization
function testAuthentication() {
    console.log('üîç Test Autenticazione e Autorizzazione...');
    
    // Check session configuration
    const serverFile = './server.js';
    const scan = scanFile(serverFile);
    
    if (scan) {
        let hasSessionSecret = false;
        let hasSecureCookie = false;
        let hasHttpOnly = false;
        
        scan.lines.forEach((line, index) => {
            if (line.includes('session') && line.includes('secret')) {
                hasSessionSecret = true;
                if (line.includes('"secret"') || line.includes("'secret'")) {
                    addVulnerability(
                        VULNERABILITY_CATEGORIES.CRITICAL,
                        'Session Security',
                        `Secret di sessione hardcodato: ${line.trim()}`,
                        serverFile,
                        index + 1
                    );
                }
            }
            
            if (line.includes('secure:') && line.includes('true')) hasSecureCookie = true;
            if (line.includes('httpOnly:') && line.includes('true')) hasHttpOnly = true;
        });
        
        if (!hasSessionSecret) {
            addVulnerability(VULNERABILITY_CATEGORIES.HIGH, 'Session Security', 'Configurazione session secret mancante', serverFile);
        }
        if (!hasSecureCookie) {
            addVulnerability(VULNERABILITY_CATEGORIES.MEDIUM, 'Session Security', 'Cookie secure flag mancante', serverFile);
        }
        if (!hasHttpOnly) {
            addVulnerability(VULNERABILITY_CATEGORIES.MEDIUM, 'Session Security', 'Cookie httpOnly flag mancante', serverFile);
        }
    }
    
    // Check for hardcoded credentials
    const allFiles = scanDirectory('.', ['.js', '.json', '.env']);
    allFiles.forEach(file => {
        const scan = scanFile(file);
        if (!scan) return;
        
        scan.lines.forEach((line, index) => {
            const lowerLine = line.toLowerCase();
            if ((lowerLine.includes('password') && lowerLine.includes('=')) ||
                (lowerLine.includes('pwd') && lowerLine.includes('=')) ||
                (lowerLine.includes('token') && lowerLine.includes('='))) {
                
                if (!lowerLine.includes('process.env') && !lowerLine.includes('req.body') && 
                    !lowerLine.includes('bcrypt') && !lowerLine.includes('hash')) {
                    addVulnerability(
                        VULNERABILITY_CATEGORIES.HIGH,
                        'Hardcoded Credentials',
                        `Possibili credenziali hardcoded: ${line.trim()}`,
                        file,
                        index + 1
                    );
                }
            }
        });
    });
}

// 4. Encryption & Cryptography
function testCryptography() {
    console.log('üîç Test Crittografia...');
    
    const cryptoFiles = scanDirectory('.', ['.js']);
    
    cryptoFiles.forEach(file => {
        const scan = scanFile(file);
        if (!scan) return;
        
        scan.lines.forEach((line, index) => {
            // Weak hashing algorithms
            if (line.includes('crypto.createHash(') && 
                (line.includes('"md5"') || line.includes("'md5'") || 
                 line.includes('"sha1"') || line.includes("'sha1'"))) {
                addVulnerability(
                    VULNERABILITY_CATEGORIES.HIGH,
                    'Weak Cryptography',
                    `Algoritmo hash debole: ${line.trim()}`,
                    file,
                    index + 1
                );
            }
            
            // Hardcoded crypto keys
            if ((line.includes('crypto.createCipher') || line.includes('crypto.createDecipher')) &&
                (line.includes('"') || line.includes("'"))) {
                addVulnerability(
                    VULNERABILITY_CATEGORIES.CRITICAL,
                    'Hardcoded Crypto Key',
                    `Chiave crittografica hardcoded: ${line.trim()}`,
                    file,
                    index + 1
                );
            }
            
            // Deprecated crypto methods
            if (line.includes('crypto.createCipher(') || line.includes('crypto.createDecipher(')) {
                addVulnerability(
                    VULNERABILITY_CATEGORIES.MEDIUM,
                    'Deprecated Crypto',
                    `Metodo crittografico deprecato: ${line.trim()}`,
                    file,
                    index + 1
                );
            }
        });
    });
}

// 5. File System Security
function testFileSystem() {
    console.log('üîç Test Sicurezza File System...');
    
    const jsFiles = scanDirectory('.', ['.js']);
    
    jsFiles.forEach(file => {
        const scan = scanFile(file);
        if (!scan) return;
        
        scan.lines.forEach((line, index) => {
            // Path traversal
            if ((line.includes('fs.readFile') || line.includes('fs.writeFile') || 
                 line.includes('fs.unlink') || line.includes('require(')) &&
                (line.includes('req.') || line.includes('params.') || line.includes('query.'))) {
                
                if (!line.includes('path.join') && !line.includes('path.resolve') && 
                    !line.includes('path.normalize')) {
                    addVulnerability(
                        VULNERABILITY_CATEGORIES.HIGH,
                        'Path Traversal',
                        `Possibile path traversal: ${line.trim()}`,
                        file,
                        index + 1
                    );
                }
            }
            
            // Unsafe file operations
            if (line.includes('child_process.exec') && 
                (line.includes('req.') || line.includes('params.') || line.includes('query.'))) {
                addVulnerability(
                    VULNERABILITY_CATEGORIES.CRITICAL,
                    'Command Injection',
                    `Possibile command injection: ${line.trim()}`,
                    file,
                    index + 1
                );
            }
        });
    });
}

// 6. Input Validation
function testInputValidation() {
    console.log('üîç Test Validazione Input...');
    
    const routeFiles = scanDirectory('./routes', ['.js']);
    
    routeFiles.forEach(file => {
        const scan = scanFile(file);
        if (!scan) return;
        
        let hasValidation = false;
        scan.lines.forEach((line, index) => {
            if (line.includes('req.body') || line.includes('req.params') || line.includes('req.query')) {
                // Check if there's validation nearby
                const context = scan.lines.slice(Math.max(0, index - 3), Math.min(scan.lines.length, index + 3));
                const hasNearbyValidation = context.some(contextLine => 
                    contextLine.includes('validator') || contextLine.includes('joi') || 
                    contextLine.includes('express-validator') || contextLine.includes('length') ||
                    contextLine.includes('trim()') || contextLine.includes('escape()')
                );
                
                if (!hasNearbyValidation) {
                    addVulnerability(
                        VULNERABILITY_CATEGORIES.MEDIUM,
                        'Input Validation',
                        `Input senza validazione: ${line.trim()}`,
                        file,
                        index + 1
                    );
                }
            }
        });
    });
}

// 7. HTTPS and Transport Security
function testTransportSecurity() {
    console.log('üîç Test Sicurezza Transport...');
    
    const serverFile = './server.js';
    const scan = scanFile(serverFile);
    
    if (scan) {
        let hasHTTPS = false;
        let hasHSTS = false;
        let hasCSP = false;
        
        scan.lines.forEach((line, index) => {
            if (line.includes('https.createServer') || line.includes('app.use(https')) {
                hasHTTPS = true;
            }
            if (line.includes('helmet') || line.includes('Strict-Transport-Security')) {
                hasHSTS = true;
            }
            if (line.includes('Content-Security-Policy')) {
                hasCSP = true;
            }
        });
        
        if (!hasHTTPS) {
            addVulnerability(VULNERABILITY_CATEGORIES.HIGH, 'Transport Security', 'HTTPS non configurato', serverFile);
        }
        if (!hasHSTS) {
            addVulnerability(VULNERABILITY_CATEGORIES.MEDIUM, 'Transport Security', 'HSTS headers mancanti', serverFile);
        }
        if (!hasCSP) {
            addVulnerability(VULNERABILITY_CATEGORIES.MEDIUM, 'Transport Security', 'Content Security Policy mancante', serverFile);
        }
    }
}

// 8. Dependency Security
function testDependencies() {
    console.log('üîç Test Sicurezza Dipendenze...');
    
    const packageFile = './package.json';
    const scan = scanFile(packageFile);
    
    if (scan) {
        try {
            const pkg = JSON.parse(scan.content);
            
            // Check for known vulnerable packages (simplified list)
            const vulnerablePackages = {
                'lodash': '<4.17.19',
                'express': '<4.17.0',
                'moment': '*',  // deprecated
                'request': '*', // deprecated
                'node-sass': '*' // deprecated
            };
            
            const allDeps = { ...pkg.dependencies, ...pkg.devDependencies };
            
            Object.entries(vulnerablePackages).forEach(([pkgName, version]) => {
                if (allDeps[pkgName]) {
                    addVulnerability(
                        VULNERABILITY_CATEGORIES.MEDIUM,
                        'Vulnerable Dependency',
                        `Dipendenza potenzialmente vulnerabile: ${pkgName}@${allDeps[pkgName]}`,
                        packageFile
                    );
                }
            });
            
        } catch (err) {
            addVulnerability(VULNERABILITY_CATEGORIES.LOW, 'Package Config', 'Errore parsing package.json', packageFile);
        }
    }
}

// 9. Database Security
function testDatabaseSecurity() {
    console.log('üîç Test Sicurezza Database...');
    
    const dbFiles = scanDirectory('./models', ['.js']);
    
    dbFiles.forEach(file => {
        const scan = scanFile(file);
        if (!scan) return;
        
        scan.lines.forEach((line, index) => {
            // Check for database connection strings with credentials
            if (line.includes('sqlite://') || line.includes('mysql://') || line.includes('postgres://')) {
                if (line.includes(':') && line.includes('@')) {
                    addVulnerability(
                        VULNERABILITY_CATEGORIES.HIGH,
                        'Database Security',
                        `Credenziali database in stringa connessione: ${line.trim()}`,
                        file,
                        index + 1
                    );
                }
            }
            
            // Check for missing error handling in DB operations
            if ((line.includes('db.run') || line.includes('db.get') || line.includes('db.all')) &&
                !line.includes('catch') && !line.includes('callback')) {
                
                const nextLines = scan.lines.slice(index, index + 3);
                const hasErrorHandling = nextLines.some(nextLine => 
                    nextLine.includes('catch') || nextLine.includes('error') || nextLine.includes('err')
                );
                
                if (!hasErrorHandling) {
                    addVulnerability(
                        VULNERABILITY_CATEGORIES.MEDIUM,
                        'Database Security',
                        `Operazione DB senza gestione errori: ${line.trim()}`,
                        file,
                        index + 1
                    );
                }
            }
        });
    });
}

// 10. Information Disclosure
function testInformationDisclosure() {
    console.log('üîç Test Information Disclosure...');
    
    const allFiles = scanDirectory('.', ['.js', '.ejs', '.json']);
    
    allFiles.forEach(file => {
        const scan = scanFile(file);
        if (!scan) return;
        
        scan.lines.forEach((line, index) => {
            // Check for console.log in production code
            if (line.includes('console.log') || line.includes('console.error') || line.includes('console.warn')) {
                addVulnerability(
                    VULNERABILITY_CATEGORIES.LOW,
                    'Information Disclosure',
                    `Console logging in produzione: ${line.trim()}`,
                    file,
                    index + 1
                );
            }
            
            // Check for stack trace exposure
            if (line.includes('res.send(error') || line.includes('res.json(error') || 
                line.includes('res.send(err') || line.includes('res.json(err')) {
                addVulnerability(
                    VULNERABILITY_CATEGORIES.MEDIUM,
                    'Information Disclosure',
                    `Possibile esposizione stack trace: ${line.trim()}`,
                    file,
                    index + 1
                );
            }
        });
    });
}

// ========================================
// ESECUZIONE TEST
// ========================================
async function runAllTests() {
    console.log('üöÄ Avvio test di sicurezza completi...\n');
    
    testSQLInjection();
    testXSS();
    testAuthentication();
    testCryptography();
    testFileSystem();
    testInputValidation();
    testTransportSecurity();
    testDependencies();
    testDatabaseSecurity();
    testInformationDisclosure();
    
    // ========================================
    // REPORT FINALE
    // ========================================
    console.log('\n' + '='.repeat(80));
    console.log('üìä VULNERABILITY TEST REPORT - ICONIC Dashboard');
    console.log('='.repeat(80));
    
    console.log(`\nüìà STATISTICHE SCANSIONE:`);
    console.log(`   ‚Ä¢ File scansionati: ${scannedFiles}`);
    console.log(`   ‚Ä¢ Linee di codice: ${totalLines.toLocaleString()}`);
    console.log(`   ‚Ä¢ Vulnerabilit√† trovate: ${vulnerabilities.length}`);
    
    // Raggruppa per severit√†
    const bySeverity = vulnerabilities.reduce((acc, vuln) => {
        acc[vuln.severity] = (acc[vuln.severity] || 0) + 1;
        return acc;
    }, {});
    
    console.log(`\nüö® VULNERABILIT√Ä PER SEVERIT√Ä:`);
    Object.entries(bySeverity).forEach(([severity, count]) => {
        console.log(`   ‚Ä¢ ${severity}: ${count}`);
    });
    
    // Raggruppa per categoria
    const byCategory = vulnerabilities.reduce((acc, vuln) => {
        acc[vuln.category] = (acc[vuln.category] || 0) + 1;
        return acc;
    }, {});
    
    console.log(`\nüìã VULNERABILIT√Ä PER CATEGORIA:`);
    Object.entries(byCategory).forEach(([category, count]) => {
        console.log(`   ‚Ä¢ ${category}: ${count}`);
    });
    
    console.log(`\nüîç DETTAGLIO VULNERABILIT√Ä:`);
    console.log('-'.repeat(80));
    
    vulnerabilities.forEach((vuln, index) => {
        console.log(`\n${index + 1}. ${vuln.severity} - ${vuln.category}`);
        console.log(`   üìÑ File: ${vuln.file}${vuln.line ? `:${vuln.line}` : ''}`);
        console.log(`   üìù Descrizione: ${vuln.description}`);
    });
    
    // ========================================
    // RACCOMANDAZIONI FINALI
    // ========================================
    console.log('\n' + '='.repeat(80));
    console.log('üí° RACCOMANDAZIONI DI SICUREZZA');
    console.log('='.repeat(80));
    
    const criticalCount = bySeverity[VULNERABILITY_CATEGORIES.CRITICAL] || 0;
    const highCount = bySeverity[VULNERABILITY_CATEGORIES.HIGH] || 0;
    
    if (criticalCount > 0) {
        console.log(`\nüî¥ ATTENZIONE: ${criticalCount} vulnerabilit√† CRITICHE trovate!`);
        console.log('   ‚û§ Risolvere IMMEDIATAMENTE prima del deploy in produzione');
    }
    
    if (highCount > 0) {
        console.log(`\nüü† AVVISO: ${highCount} vulnerabilit√† ad ALTO rischio trovate!`);
        console.log('   ‚û§ Risolvere prima possibile');
    }
    
    console.log('\nüìö BEST PRACTICES CONSIGLIATE:');
    console.log('   1. üõ°Ô∏è  Usare parametri preparati per tutte le query SQL');
    console.log('   2. üîê Implementare validazione e sanitizzazione input completa');
    console.log('   3. üåê Configurare HTTPS e security headers (helmet.js)');
    console.log('   4. üîë Non hardcodare mai credenziali o chiavi crypto');
    console.log('   5. üìù Rimuovere console.log dal codice di produzione');
    console.log('   6. üîÑ Aggiornare regolarmente le dipendenze');
    console.log('   7. üß™ Implementare test di sicurezza automatici');
    console.log('   8. üìä Monitorare e log degli accessi sospetti');
    
    const riskLevel = criticalCount > 0 ? 'üî¥ ALTO RISCHIO' : 
                      highCount > 0 ? 'üü† MEDIO RISCHIO' : 'üü¢ BASSO RISCHIO';
    
    console.log(`\nüéØ VALUTAZIONE FINALE: ${riskLevel}`);
    
    if (vulnerabilities.length === 0) {
        console.log('\nüéâ COMPLIMENTI! Nessuna vulnerabilit√† rilevata dal test automatico.');
        console.log('   ‚ö†Ô∏è  NOTA: Questo test non sostituisce un audit di sicurezza professionale');
    }
    
    console.log('\n‚úÖ Vulnerability test completato!');
    console.log('üìÖ Timestamp:', new Date().toLocaleString());
}

// Avvia i test
runAllTests().catch(console.error);